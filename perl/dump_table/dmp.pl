#!/usr/bin/perl
#
# $Id: dmp.pl 6 2006-09-10 15:35:16Z marcus $
# $Revision: 1.5 $  $Author: marcus $
#
# dump_results()

use strict;
use DBI;

usage() unless @ARGV;

# Params
my $sid =    $ARGV[0] ;
my $tab = lc($ARGV[1]) ;
my $usr =    $ARGV[2] || "UXML";
my $psw =    $ARGV[3] || $usr  ;

# Variables
my $dbh;
my @columns;
my (@col_id, @col_pk);

conn_db( $usr, $psw, $sid );

# The work to be done.....
@columns = get_columns( $usr, $tab );
upd_table( $usr, $tab);
make_trigger( $usr, $tab);

# end
$dbh->disconnect;
exit 0;

sub usage()
{
    die <<"    USAGE";

    Usage: $0 SID tab_name user [<password>]

        SID:        Database/tns_alias
        tab_name:   table name
        user:       username
        <password>: password

        Generates
            tab_name.ctl        loads table
            tab_name.pl         spools table
            tab_name_ins.sql    INSERT/SELECT on table
            tab_name_ins_pl.sql INSERT/SELECT using PL/SQL block.


    USAGE
}

sub conn_db()
{
    print "\n\n    $usr\@$sid Connecting.... ";

    # error Checking
    my %attr = ( PrintError => 1
               , RaiseError => 1
               );
    # Connect
    $dbh = DBI->connect("dbi:Oracle:$sid","$usr"
                                         ,"$psw"
                                         , \%attr
                                        )
                or die "\nCannot connect : ", $DBI::errstr, "\n" ;

    print "ok\n\n";
}

sub get_columns()
{
    # Table columns in a list

    my $owner = shift;
    my $tab   = shift;
    my $sth;
    my @cols;
    my ($colname, $colid, $colpk);
    my $sql = <<"    SQL";
    /* $0 */
    SELECT LOWER(col.column_name) col_name
         , col.column_id          col_id
         , pk.constraint_type     col_pk
      FROM all_tab_columns   col
         , (SELECT cc.table_name
                 , cc.column_name
                 , co.constraint_type
              FROM all_cons_columns  cc
                 , all_constraints   co
             WHERE 1=1
               AND cc.owner           = :1
               AND cc.table_name      = :2
               AND cc.owner           = co.owner
               AND cc.table_name      = co.table_name
               AND co.constraint_type = 'P'
               AND co.constraint_name = cc.constraint_name ) pk
     WHERE col.owner           = :1
       AND col.table_name      = :2
       AND col.table_name      = pk.table_name  (+)
       AND col.column_name     = pk.column_name (+)
     ORDER BY col.column_id
    SQL

    # fetching it
    $sth=$dbh->prepare ($sql);
    $sth->bind_param( 1, uc($owner) );
    $sth->bind_param( 2, uc($tab)   );
    $sth->execute;

    while ( ($colname, $colid, $colpk) = $sth->fetchrow_array )
    {
        push @cols   , $colname; # local
        push @col_id , $colid;   # global
        push @col_pk , $colpk;   # global
    }

    die "No columns found for $owner.$tab .\n\n" unless defined @cols;
    die "No pk defined for $owner.$tab . \n\n"   unless defined @col_pk;

    return @cols;
}

sub upd_table()
{
    # gen: perl code to make a upd table from a csv file

    my $owner = shift;
    my $tab   = shift;

    my ($ins, $upd);
    my ($list1, $list2, @list1, @list2, @list_bind);

    # insert
    $list1 =       join ( "\n" . " " x 14 . ", "  , @columns );
    $list2 = ":" . join ( "\n" . " " x 14 . ", :" , @col_id );
    $ins = << "    INS";
    INSERT INTO $owner.$tab
              ( $list1
              )
       VALUES ( $list2
              )
    INS
    #print "ins \n$ins \n";

    # update
    for ( my $i=0; $i <= scalar(@columns)-1; $i++ )
    {
        # WHERE and SET
        if ( $col_pk[$i] eq 'P' )
        {
            push @list2, $columns[$i] . " " x (25 - length($columns[$i])) . " = :". $col_id[$i];
        }
        else
        {
            push @list1, $columns[$i] . " " x (25 - length($columns[$i])) . " = :". $col_id[$i];
        };

        # bind_param
        push @list_bind, $col_id[$i] . ", \$v_" . $columns[$i] ;
    }
    $list1 = join( "\n" . " " x 13 . ", "  , @list1 );
    $list2 = join( "\n" . " " x 11 . "AND ", @list2 );
    my $upd = << "    UPD";
    BEGIN
        UPDATE $owner.$tab
           SET $list1
         WHERE $list2
             ;
    EXCEPTION
        WHEN balance.record_exists THEN NULL;
    END;
    UPD
    #print "upd \n$upd \n";

    # list of local variables
    my $list_var = "( \$v_" . join( "\n    , \$v_", @columns);

    # list of bind_param
    my $list_bind1 = "\$st1->bind_param( " . join( ");\n    \$st1->bind_param( ", @list_bind) . ");";
    my $list_bind2 = "\$st2->bind_param( " . join( ");\n        \$st2->bind_param( ", @list_bind) . ");";


    my $code = <<"    TEMPLATE";
    CODE #!perl
    CODE #
    CODE # Generated by: $0
    CODE #
    CODE # upd_table()
    CODE
    CODE use DBI;
    CODE
    CODE # Params
    CODE my \$user = "$usr";
    CODE my \$psw  = "$psw";
    CODE my \$sid  = "$sid";
    CODE my \$arq  = "$tab.csv";
    CODE my \$log  = "$tab.log";
    CODE my \$bad  = "$tab.bad";
    CODE
    CODE my (\$kount, \$rc);
    CODE
    CODE my \$ins  = << "INS";
    CODE $ins
    CODE INS
    CODE
    CODE my \$upd  = << "UPD";
    CODE $upd
    CODE UPD
    CODE
    CODE # db session properties
    CODE my \%attr =  ( PrintError => 0
    CODE             , RaiseError => 0
    CODE             , AutoCommit => 0
    CODE             );
    CODE # Connect
    CODE my \$dbh = DBI->connect ( "dbi:Oracle:\$sid"
    CODE                        , "\$user"
    CODE                        , "\$psw"
    CODE                        , \\%attr
    CODE                        )
    CODE             or die "Cannot connect : ", \$DBI::errstr, "\\n" ;
    CODE
    CODE
    CODE my \$sth = \$dbh->do("alter session set nls_date_format='dd/mm/yyyy hh24:mi:ss'");
    CODE    \$sth = \$dbh->do("begin dbms_reputil.replication_off; end;");
    CODE    \$sth = \$dbh->do("begin dbms_application_info.set_module('perl: \$0 '); end;");
    CODE
    CODE my \$st1 = \$dbh->prepare( \$ins );
    CODE my \$st2 = \$dbh->prepare( \$upd );
    CODE
    CODE
    CODE # File to process
    CODE open FILE, "<\$arq"
    CODE     or die "Cannot open csv file: \$!\\n";
    CODE
    CODE # Outputs
    CODE open LOG, ">\$log"
    CODE     or die "Cannot open log file: \$!\\n";
    CODE
    CODE open BAD, ">\$bad"
    CODE     or die "Cannot open bad file: \$!\\n";
    CODE
    CODE
    CODE # Processing lines
    CODE while ( \$line = <FILE> )
    CODE {
    CODE     \$kount++;
    CODE     \$line = substr( \$line, 1, length(\$line)-3); # trimming double quotes
    CODE
    CODE     $list_var
    CODE     ) = split( /\|;\|/, \$line);
    CODE
    CODE     \$sth = \$dbh->do("begin DBMS_APPLICATION_INFO.SET_ACTION
    CODE                         ( 'Progress: '||TO_CHAR(\$kount ,'999g999g999g990') ); end;");
    CODE
    CODE     $list_bind1
    CODE     \$st1->execute();
    CODE
    CODE     if ( \$DBI::err )
    CODE     {
    CODE         $list_bind2
    CODE         \$st2->execute();
    CODE
    CODE         if ( \$DBI::err )
    CODE         {
    CODE             \$kount_err++;
    CODE             print LOG "\$kount_err (\$kount) :\$DBI::errstr \\n";
    CODE             print BAD '"', \$line, '"', "\\n";
    CODE         }
    CODE     }
    CODE
    CODE     if ( \$kount % 5000 == 0)
    CODE     {
    CODE         \$rc = \$dbh->commit;
    CODE         print "Commit \$kount \\n";
    CODE     }
    CODE }
    CODE
    CODE # end
    CODE \$rc = \$dbh->commit;
    CODE print "Commit \$kount\\n";
    CODE \$dbh->disconnect;
    CODE
    CODE close FILE
    CODE     or die "Cannot close result file: \$! \\n";
    CODE
    CODE close LOG
    CODE     or die "Cannot close log file: \$! \\n";
    CODE
    CODE close BAD
    CODE     or die "Cannot close bad file: \$! \\n";
    CODE
    TEMPLATE

    open FILE, ">${tab}.upd.pl"
        or die "Cannot open ${tab}.upd.pl : $! \n";

    print FILE fmt($code);

    close FILE
        or die "Cannot close ${tab}.upd.pl : $! \n";

}

sub make_trigger()
{
    #### Trigger for update (replication)
    #my $list1 =         join ( "\n         , "                 , @columns );
    #my $list2 =         join ( "\n                      , "    , @columns );
    #my $list3 = "r1." . join ( "\n                      , r1." , @columns );

    my $owner = shift;
    my $tab   = shift;
    my $colname;
    my $trigger = "tbu_repl_" . substr( $tab, 0, 21 ) ;

    my $now = localtime ;
    my $condition = "";
    my $separator = "IF  ";
    my $new = "\:NEW." ;
    my $old = "\:OLD." ;
    my $largest = 0;

    # max column size
    foreach $colname (@columns)
    {
        $largest = length ( $colname ) if length( $colname ) > $largest ;
    }
    my $mask = "A" . $largest;

    # condition text
    foreach $colname (@columns)
    {
        $condition .= $separator . $new . pack( $mask, $colname )
                         . " = " . $old . $colname ;
        $separator = "\n    AND ";
    }

    my $code = <<"    TRIGGER" ;
    CODE CREATE OR REPLACE TRIGGER $owner.$trigger
    CODE     BEFORE UPDATE
    CODE         ON $tab
    CODE        FOR EACH ROW
    CODE BEGIN
    CODE     -- \$Id\$
    CODE     -- Generated by $0 ( $now )
    CODE     -- Criado:
    CODE     --      Marcus Vinicius Ferreira    Fev/2005
    CODE     --
    CODE     -- OBS: updates onde TODOS os valores antes e depois SAO IGUAIS
    CODE     --      sao ignorados para diminuir "overhead" na replicacao
    CODE     --
    CODE     $condition
    CODE     THEN
    CODE         RAISE balance.record_exists;
    CODE     END IF;
    CODE     --
    CODE END;
    CODE /
    CODE
    CODE show err
    CODE
    TRIGGER

    open FILE, "> ${tab}.repl.trg.sql"
        or die "Cannot open ${tab}.repl.trg.sql : $! \n";

    print FILE fmt($code);

    close FILE
        or die "Cannot close ${tab}.repl.trg.sql : $! \n";
}

sub fmt()
{
    my $code = shift;
    $code =~ s/^\s*CODE //gm;   # CODE followed by content
    $code =~ s/^\s*CODE$/ /gm; # CODE alone in one line (i.e., empty line)
    return $code;
}

__END__
