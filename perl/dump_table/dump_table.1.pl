#!/usr/bin/perl
#
# $Id: dump_table.1.pl 6 2006-09-10 15:35:16Z marcus $
# $Revision: 1.5 $  $Author: marcus $
#
# dump_results()

use strict;
use DBI;

usage() unless @ARGV;

# Params
my $sid =    $ARGV[0] ;
my $tab = lc($ARGV[1]) ;
my $usr =    $ARGV[2] || "UXML";
my $psw =    $ARGV[3] || $usr  ;

# Variables
my $dbh;
conn_db( $usr, $psw, $sid );

# The work to be done.....
my @columns = get_columns( $usr, $tab );
make_spool();
make_ctl();
make_ins_sel();
make_ins_sel_pl();

# end
$dbh->disconnect;
exit 0;

sub usage()
{
    die <<"    USAGE";

    Usage: $0 SID tab_name user [<password>]

        SID:        Database/tns_alias
        tab_name:   table name
        user:       username
        <password>: password

        Generates
            tab_name.ctl        loads table
            tab_name.pl         spools table
            tab_name_ins.sql    INSERT/SELECT on table
            tab_name_ins_pl.sql INSERT/SELECT using PL/SQL block.


    USAGE
}

sub conn_db()
{
    print "\n\n    Connecting.... $usr\@$sid\n\n";

    # error Checking
    my %attr = ( PrintError => 1
               , RaiseError => 1
               );
    # Connect
    $dbh = DBI->connect("dbi:Oracle:$sid","$usr"
                                         ,"$psw"
                                         , \%attr
                                        )
                or die "Cannot connect : ", $DBI::errstr, "\n" ;
}

sub get_columns()
{
    my $owner = shift;
    my $tab = shift;
    my $sth;
    my $sql = <<"    SQL";
    /* $0 */
    SELECT LOWER(column_name) column_name
      FROM all_tab_columns
     WHERE owner      = :1
       AND table_name = :2
     ORDER BY column_id
    SQL
    $sth = $dbh->prepare ($sql);
    $sth->bind_param( 1, uc($owner) );
    $sth->bind_param( 2, uc($tab)   );
    $sth->execute;

    my ($colname, @cols);
    while ( $colname = $sth->fetchrow_array )
    {
        push @cols, $colname;
    }

    die "No columns found for $owner.$tab .\n\n" unless defined @cols;

    return @cols;
}


sub make_ctl()
{
    #### Control file
    my $list = join ( "\n, "     , @columns );
    my $code = <<"    CTL" ;
    CODE -- Generated by:
    CODE --    $0
    CODE --
    CODE -- Errors: 1.000.000.000 -- 1 billion, i.e., all rows in the file
    CODE --   Rows:     1.000.000
    CODE -- Bind/ReadSize : 20M (Solaris8 32bit, Oracle 8.1.7)
    CODE --                  2M
    CODE --
    CODE OPTIONS ( ERRORS=999999999
    CODE         ,   ROWS=100000
    CODE         , DIRECT=FALSE
    CODE      -- , BINDSIZE=20971520
    CODE      -- , READSIZE=20971520
    CODE         , BINDSIZE=2097152
    CODE         , READSIZE=2097152
    CODE         )
    CODE LOAD DATA
    CODE INFILE $tab.csv
    CODE   INTO TABLE $tab
    CODE   APPEND
    CODE FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '"'
    CODE ( $list
    CODE )
    CODE
    CTL

    open FILE, "> ${tab}.ctl"
        or die "Cannot open ${tab}.ctl : $! \n";

    print FILE fmt($code);

    close FILE
        or die "Cannot close ${tab}.ctl : $! \n";
}

sub make_ins_sel()
{
    #### SELECT/INSERT script
    my $list = join ( "\n     , "     , @columns );
    my $code = <<"    SQL" ;
    CODE --
    CODE -- Generated by: $0
    CODE --
    CODE INSERT INTO $tab --\@dblink
    CODE      ( $list
    CODE      )
    CODE SELECT $list
    CODE   FROM $tab --\@dblink
    CODE  WHERE 1=1
    CODE /
    CODE
    SQL

    open FILE, "> ${tab}_ins.sql"
        or die "Cannot open ${tab}_ins.sql : $! \n";

    print FILE fmt($code);

    close FILE
        or die "Cannot close ${tab}_ins.sql : $! \n";

}

sub make_ins_sel_pl()
{
    #### SELECT/INSERT in PL/SQL block, with commit control
    my $list1 =         join ( "\n         , "                 , @columns );
    my $list2 =         join ( "\n                      , "    , @columns );
    my $list3 = "r1." . join ( "\n                      , r1." , @columns );
    my $code = <<"    PLSQL" ;
    CODE --
    CODE -- Generated by: $0
    CODE --
    CODE DECLARE
    CODE     CURSOR c1 IS
    CODE     SELECT $list1
    CODE       FROM $tab -- \@FED.F00000000000001
    CODE      WHERE 1=1
    CODE          ;
    CODE     c   NUMBER := 0;
    CODE     k   NUMBER := 0;
    CODE     kt  NUMBER := 0;
    CODE BEGIN
    CODE     --
    CODE     -- DBMS_REPUTIL.REPLICATION_OFF;
    CODE     --
    CODE     SELECT count(1)
    CODE       INTO kt
    CODE       FROM $tab  -- \@FED.F00000000000001
    CODE      WHERE 1=1
    CODE          ;
    CODE     --
    CODE     DBMS_APPLICATION_INFO.SET_MODULE
    CODE         ( 'Balance: [$tab]' , 'START');
    CODE     --
    CODE     FOR r1 IN c1
    CODE     LOOP
    CODE         --
    CODE         BEGIN
    CODE             INSERT INTO $tab
    CODE                       ( $list2
    CODE                       )
    CODE                 VALUES( $list3
    CODE                       );
    CODE             --
    CODE             c := c + 1;
    CODE             IF c >= 5000
    CODE             THEN
    CODE                 c := 0;
    CODE                 COMMIT;
    CODE             END IF;
    CODE             --
    CODE         EXCEPTION
    CODE             WHEN DUP_VAL_ON_INDEX THEN NULL;
    CODE         END;
    CODE         --
    CODE         k := k + 1;
    CODE         DBMS_APPLICATION_INFO.SET_ACTION
    CODE             ( 'Progress: '||TO_CHAR(k ,'999g999g999g990')||'/'
    CODE                           ||TO_CHAR(kt,'999g999g999g990') );
    CODE         --
    CODE     END LOOP;
    CODE     --
    CODE     -- COMMIT;
    CODE     -- DBMS_REPUTIL.REPLICATION_ON;
    CODE     --
    CODE     DBMS_APPLICATION_INFO.SET_ACTION
    CODE         ( 'Final: '||TO_CHAR(k ,'999g999g999g990')||'/'
    CODE                    ||TO_CHAR(kt,'999g999g999g990') );
    CODE END;
    CODE /
    CODE
    PLSQL

    open FILE, "> ${tab}_ins_pl.sql"
        or die "Cannot open ${tab}_ins_pl.sql : $! \n";

    print FILE fmt($code);

    close FILE
        or die "Cannot close ${tab}_ins_pl.sql : $! \n";
}

sub make_spool()
{
    #### Spool Generator
    my $list = join ( "\n     , " , @columns );
    my $code = <<"    TEMPLATE";
    CODE #!perl
    CODE #
    CODE # Generated by: $0
    CODE #
    CODE # dump_results()
    CODE
    CODE use DBI;
    CODE
    CODE # Params
    CODE my \$user = "$usr";
    CODE my \$psw  = "$psw";
    CODE my \$sid  = "$sid";
    CODE my \$arq  = "$tab.csv";
    CODE my \$sql  = "
    CODE SELECT $list
    CODE   FROM $tab
    CODE        ";
    CODE
    CODE # error Checking
    CODE my \%attr =  (   PrintError => 1
    CODE             ,   RaiseError => 1
    CODE             );
    CODE # Connect
    CODE my \$dbh = DBI->connect ("dbi:Oracle:\$sid"
    CODE                        ,"\$user"
    CODE                        ,"\$psw"
    CODE                        ,\\\%attr
    CODE                        )
    CODE             or die "Cannot connect : ", \$DBI::errstr, "\\n" ;
    CODE
    CODE my \$sth = \$dbh->do("alter session set nls_date_format='dd/mm/yyyy hh24:mi:ss'");
    CODE    \$sth = \$dbh->prepare( \$sql );
    CODE    \$sth->execute();
    CODE
    CODE # dump file
    CODE open FILE, ">\$arq"
    CODE     or die "Cannot open csv file: \$!\\n";
    CODE
    CODE while ( \@rows = \$sth->fetchrow_array )
    CODE {
    CODE     print FILE '"'
    CODE              , join( '";"', \@rows)
    CODE              , '"'
    CODE              , "\\n";
    CODE }
    CODE
    CODE close FILE
    CODE     or die "Cannot close result file: \$! \\n";
    CODE
    CODE # end
    CODE \$dbh->disconnect;
    CODE
    TEMPLATE

    open FILE, ">${tab}.pl"
        or die "Cannot open ${tab}.pl : $! \n";

    print FILE fmt($code);

    close FILE
        or die "Cannot close ${tab}.pl : $! \n";

}

sub fmt()
{
    my $code = shift;
    $code =~ s/^\s*CODE //gm;   # CODE followed by content
    $code =~ s/^\s*CODE$/\n/gm; # CODE alone in one line (i.e., empty line)
    return $code;
}

__END__
